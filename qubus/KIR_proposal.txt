Proposal

split the IR into several parts

expressions
statements (?)

and

declarations

expressions and statements have value semantics

declarations should have reference semantics due to their non-local ownership (variable_references must always point to the correct declaration)

declarations have an optional initializer (which is an expression object)

How to implement this?

Note: It shouldn't matter if the declaration is boxed or unboxed! Do we even need polymorphism for variable declarations?
      Do we need other type of declarations? 

(1) Each declaration object contains its internal state via a (shared) pointer

Pros:

* it doesn't matter if the object is boxed or unboxed; the property is always enforced

Cons:

* the variable reference only knows the internal state, which would be a distinct object

(2) Each declaration object is managed via a (shared) pointer

Pros:

Cons:

* we can't enforce this (but we could make it non-copyable/non-movable)

* problematic if we need to unbox and rebox the declaration (this would imply a copy/move)


Decision:

use runtime polymorphism to implement this




for i, j in [0, dfloor(N, L)] x [0, dfloor(N, L)]
{
    tileA = A[i*L:(i + 1)*L, ...]

    for ii, jj in [0, L] x [0, L]
    {
        tileA[ii, jj]
    }

    // we need to destroy all cached tiles here and
    // write their changes to the original location
    // if necessary

    // how do we avoid bad access to the parent object?
    // Do we need to do this
    // Should tiles (windows?) shadow their parent object (probably yes)

    // important: multiple slices can't overlap
}